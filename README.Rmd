---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "##",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

<!-- [![Travis build status](https://travis-ci.org/daijiang/phyr.svg?branch=master)](https://travis-ci.org/daijiang/phyr) [![Coverage status](https://codecov.io/gh/daijiang/phyr/branch/master/graph/badge.svg)](https://codecov.io/gh/daijiang/phyr) -->

# phyr

The goal of phyr is to collect and update (with c++ for core parts) functions that:

- calculate alpha phylogenetic diversity (`psv`, `psr`, `pse`, etc.) and beta phylogenetic diversity (`pcd`) from the picante package
- fitting phylogenetic logistic regressions (`binaryPGLMM`) from the ape package
- fitting models to estimate correlation between functional traits while accounting for phylogenetic relationships (`corphylo`) from the ape package; now named as `cor_phylo`
- fitting phylogenetic generalized linear mixed models (`communityPGLMM`) from the pez package; now named as `pglmm`
- and more.

These functions share some similarities and it makes more sense to put them in one package to reduce redundancy in codes and to facilitate updates. Furthermore, we upgraded these functions with new and more user-friendly interfaces and features. Key parts are written with c++ to improve performance.

# Installation

To install this package:

```{r eval = F}
devtools::install_github("daijiang/phyr")
# or (may not be the latest version)
# macOS
install.packages("https://raw.githubusercontent.com/daijiang/phyr/master/phyr_0.1.6.tgz", repos = NULL)
# Windows
install.packages("https://raw.githubusercontent.com/daijiang/phyr/master/phyr_0.1.6.zip", repos = NULL)
```

```{r message=FALSE}
library(phyr)
```


# Benchmark for PSV family functions

## `psv`

```{r}
nspp = 500
nsite = 100
tree_sim = ape::rtree(n = nspp)
comm_sim = matrix(rbinom(nspp * nsite, size = 1, prob = 0.6), 
                  nrow = nsite, ncol = nspp)
row.names(comm_sim) = paste0("site_", 1:nsite)
colnames(comm_sim) = paste0("t", 1:nspp)
comm_sim = comm_sim[, tree_sim$tip.label]
# about 40 times faster
microbenchmark::microbenchmark(
  picante::psv(comm_sim, tree_sim),
  psv(comm_sim, tree_sim, cpp = FALSE),
  psv(comm_sim, tree_sim, cpp = TRUE),
  times = 10)
```

## `pse`

```{r}
comm_sim = matrix(rpois(nspp * nsite, 3), nrow = nsite, ncol = nspp)
row.names(comm_sim) = paste0("site_", 1:nsite)
colnames(comm_sim) = paste0("t", 1:nspp)
comm_sim = comm_sim[, tree_sim$tip.label]
# about 8 times faster
microbenchmark::microbenchmark(
  picante::pse(comm_sim, tree_sim),
  pse(comm_sim, tree_sim, cpp = FALSE),
  pse(comm_sim, tree_sim, cpp = TRUE),
  times = 10)
```

## `pcd`

```{r, message=FALSE}
# pcd is about 20 times faster
microbenchmark::microbenchmark(
  phyr::pcd(comm = comm_a, tree = phylotree, reps = 1000, verbose = F),
  picante::pcd(comm = comm_a, tree = phylotree, reps = 1000),
  times = 20)
```

# Community PGLMM (`pglmm`)

`pglmm` now can use similar syntax as `lme4::lmer` to specify random terms: add `__` (two underscores) at the end of grouping variable (`sp`) to specify both phylogenetic and non-phylogenetic random terms; use `(1|sp__@site)` to specify nested term. This should be the most commonly used one and is equal to `kronecker(I_site, V_sp)`. (`V_sp` is `Vphy`, used sp here so it is clearer this is for species.) 

For bipartite questions, you should also use a second phylogeny. Then use `(1|sp@site__)` and `(1|sp__@site__)` if needed. For bipartite questions, `(1|sp@site__)` will be converted to `kronecker(V_site, I_sp)`; `(1|sp__@site__)` will be converted to `kronecker(V_site, V_sp)`. (V_site is from the second phylogeny)

```{r eval = T}
library(dplyr)
comm = comm_a
comm$site = row.names(comm)
dat = tidyr::gather(comm, key = "sp", value = "freq", -site) %>% 
  left_join(envi, by = "site") %>% 
  left_join(traits, by = "sp")
dat$pa = as.numeric(dat$freq > 0)
head(dat)
# phy-LMM
test1 = phyr::pglmm(freq ~ 1 + shade + (1|sp__) + (1|site) + (1|sp__@site), 
                    data = dat, family = "gaussian", REML = F,
                    cov_ranef = list(sp = phylotree))
test1
# phy-GLMM
test3 = phyr::pglmm(pa ~ 1 + shade + (1|sp__) + (1|site) + (1|sp__@site), 
                    data = dat, family = "binomial", REML = F,
                    cov_ranef = list(sp = phylotree))
test3
# bipartite
tree_site = ape::rtree(n = n_distinct(dat$site), tip.label = sort(unique(dat$site)))
z_bipartite = phyr::pglmm(freq ~ 1 + shade + (1|sp__) + (1|site__) + 
                            (1|sp__@site) + (1|sp@site__) + (1|sp__@site__), 
                          data = dat, family = "gaussian",REML = TRUE,
                          cov_ranef = list(sp = phylotree, site = tree_site))
z_bipartite
```

To compare the cpp version and R version, and the version from the `pez` package.

```{r, warning=FALSE}
# data prep for pez::communityPGLMM, not necessary for phyr::pglmm
dat = arrange(dat, site, sp)
nspp = n_distinct(dat$sp)
nsite = n_distinct(dat$site)

dat$site = as.factor(dat$site)
dat$sp = as.factor(dat$sp)

tree = ape::drop.tip(phylotree, setdiff(phylotree$tip.label, unique(dat$sp)))
Vphy <- ape::vcv(tree)
Vphy <- Vphy/max(Vphy)
Vphy <- Vphy/exp(determinant(Vphy)$modulus[1]/nspp)
Vphy = Vphy[levels(dat$sp), levels(dat$sp)]

# prepare random effects
re.site <- list(1, site = dat$site, covar = diag(nsite))
re.sp <- list(1, sp = dat$sp, covar = diag(nspp))
re.sp.phy <- list(1, sp = dat$sp, covar = Vphy)
# sp is nested within site
re.nested.phy <- list(1, sp = dat$sp, covar = Vphy, site = dat$site)
re.nested.rep <- list(1, sp = dat$sp, covar = solve(Vphy), site = dat$site) # equal to sp__@site
# can be named 
re = list(re.sp = re.sp, re.sp.phy = re.sp.phy, re.nested.phy = re.nested.phy, re.site = re.site)

# about 4-10 times faster for a small dataset
microbenchmark::microbenchmark(
  phyr::pglmm(freq ~ 1 + shade + (1|sp__) + (1|site) + (1|sp__@site), 
              dat, cov_ranef = list(sp = phylotree), REML = F, 
              cpp = T, optimizer = "bobyqa"),
  phyr::pglmm(freq ~ 1 + shade + (1|sp__) + (1|site) + (1|sp__@site), 
              dat, cov_ranef = list(sp = phylotree), REML = F, 
              cpp = T, optimizer = "Nelder-Mead"),
  phyr::pglmm(freq ~ 1 + shade + (1|sp__) + (1|site) + (1|sp__@site), 
              dat, cov_ranef = list(sp = phylotree), REML = F, 
              cpp = F, optimizer = "Nelder-Mead"),
  pez::communityPGLMM(freq ~ 1 + shade, data = dat, sp = dat$sp, site = dat$site, 
                      random.effects = re, REML = F),
  times = 5
)

# about 6 times faster for a small dataset
microbenchmark::microbenchmark(
  phyr::pglmm(pa ~ 1 + shade + (1|sp__) + (1|site) + (1|sp__@site), dat, 
              family = "binomial", cov_ranef = list(sp = phylotree), REML = F, 
              cpp = T, optimizer = "bobyqa"),
  phyr::pglmm(pa ~ 1 + shade + (1|sp__) + (1|site) + (1|sp__@site), dat, 
              family = "binomial", cov_ranef = list(sp = phylotree), REML = F,
              cpp = T, optimizer = "Nelder-Mead"),
  phyr::pglmm(pa ~ 1 + shade + (1|sp__) + (1|site) + (1|sp__@site), dat, 
              family = "binomial", cov_ranef = list(sp = phylotree), REML = F, 
              cpp = F, optimizer = "Nelder-Mead"),
  pez::communityPGLMM(pa ~ 1 + shade, data = dat, family = "binomial", sp = dat$sp, 
                      site = dat$site, random.effects = re, REML = F),
  times = 5
)
```


