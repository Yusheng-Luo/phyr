% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pglmm.R
\name{pglmm}
\alias{pglmm}
\alias{prep_dat_pglmm}
\alias{communityPGLMM}
\alias{communityPGLMM}
\alias{communityPGLMM.gaussian}
\alias{communityPGLMM.binary}
\alias{communityPGLMM.binary.LRT}
\alias{communityPGLMM.matrix.structure}
\alias{summary.communityPGLMM}
\alias{print.communityPGLMM}
\alias{plot.communityPGLMM}
\alias{communityPGLMM.predicted.values}
\alias{communityPGLMM.bayes}
\title{Phylogenetic Generalised Linear Mixed Model for Community Data}
\usage{
prep_dat_pglmm(formula, data, tree, repulsion = FALSE,
  prep.re.effects = TRUE, family = "gaussian", prep.s2.lme4 = FALSE)

communityPGLMM(formula, data = NULL, family = "gaussian", tree,
  repulsion = FALSE, sp, site, random.effects = NULL, REML = TRUE,
  bayes = FALSE, s2.init = NULL, B.init = NULL, reltol = 10^-6,
  maxit = 500, tol.pql = 10^-6, maxit.pql = 200, verbose = FALSE,
  ML.init = TRUE, marginal.summ = "mean", calc.DIC = FALSE,
  default.prior = "inla.default", cpp = TRUE, optimizer = c("bobyqa",
  "Nelder-Mead", "nelder-mead-nlopt", "subplex"), prep.s2.lme4 = FALSE)

communityPGLMM.gaussian(formula, data = list(), family = "gaussian",
  sp = NULL, site = NULL, random.effects = list(), REML = TRUE,
  s2.init = NULL, B.init = NULL, reltol = 10^-8, maxit = 500,
  verbose = FALSE, cpp = TRUE, optimizer = "bobyqa")

communityPGLMM.binary(formula, data = list(), family = "binomial",
  sp = NULL, site = NULL, random.effects = list(), REML = TRUE,
  s2.init = 0.05, B.init = NULL, reltol = 10^-5, maxit = 40,
  tol.pql = 10^-6, maxit.pql = 200, verbose = FALSE, cpp = TRUE,
  optimizer = "bobyqa")

communityPGLMM.binary.LRT(x, re.number = 0, cpp = TRUE, ...)

communityPGLMM.matrix.structure(formula, data = list(), family = "binomial",
  tree, repulsion = FALSE, ss = 1, cpp = TRUE)

\method{summary}{communityPGLMM}(x, digits = max(3, getOption("digits") - 3),
  ...)

\method{print}{communityPGLMM}(x, digits = max(3, getOption("digits") - 3),
  ...)

\method{plot}{communityPGLMM}(x, digits = max(3, getOption("digits") - 3),
  ...)

communityPGLMM.predicted.values(x, show.plot = TRUE, ...)

communityPGLMM.bayes(formula, data = list(), family = "gaussian",
  sp = NULL, site = NULL, random.effects = list(), s2.init = NULL,
  B.init = NULL, verbose = FALSE, REML = FALSE, marginal.summ = "mean",
  calc.DIC = FALSE, default.prior = "inla.default")
}
\arguments{
\item{formula}{a two-sided linear formula object describing the
mixed-effects of the model; it follows similar syntax as \code{\link[lme4:lmer]{lmer}}.
There are some differences though: 1. to specify that a random term
should have phylogenetic cov matrix too, add "__" at the end of the group
variable, e.g. \code{+ (1 | sp__)} will construct two random terms, one
with phylogenetic cov matrix and another with non-phylogenetic (Identity) matrix;
2. to specify nested random term, use \code{+ (1|site@sp)}. Note, however,
no correlated random terms will be allowed at this moment. For example,
\code{(x|g)} will be equal with \code{(0 + x|g)} in the lmer syntax;
also, \code{(x1 + x2|g)} won't work.}

\item{data}{a \code{\link{data.frame}} containing the variables
named in formula. The data frame should have long format with
factors specifying species (named as 'sp') and sites (named as 'site'). \code{communityPGLMM} will
reorder rows of the data frame so that species are nested within
sites.}

\item{tree}{a phylogeny, with "phylo" class.}

\item{repulsion}{when nested random term specified, do you want to test repulsion or underdispersion?
Default is FALSE, i.e. test underdispersion.}

\item{prep.re.effects}{whether to prepare random effects for users.}

\item{family}{either \code{gaussian} for a Linear Mixed Model, or
\code{binomial} for binary dependent data.}

\item{prep.s2.lme4}{whether to prepare initial s2 values based on lme4 theta. Default is FALSE.
If no phylogenetic or nested random terms, should set it to TRUE since it likely will be faster.
However, in this case, you probably can just use lme4::lmer.}

\item{sp}{no longer used, keep here for compatibility}

\item{site}{no longer used, keep here for compatibility}

\item{random.effects}{pre-build list of random effects, default is NULL. Can be useful if
dealing with two phylogenies (e.g. plants and pollinators). You can prepare it with
the prep_dat_pglmm() function to get the random effects for each phylogeny and then
combine both together.}

\item{REML}{whether REML or ML is used for model fitting. For the
generalized linear mixed model for binary data, these don't have
standard interpretations, and there is no log likelihood function
that can be used in likelihood ratio tests. If \code{bayes = TRUE},
\code{REML = TRUE} will place a sum to one constraint on the random
effects, which should produce more comparable results to a REML analysis
in a maximum likelihood context.}

\item{bayes}{whether to fit a Bayesian version of the PGLMM using
\code{r-inla}}

\item{s2.init}{an array of initial estimates of s2 for each random
effect that scales the variance. If s2.init is not provided for
\code{family="gaussian"}, these are estimated using in a clunky way
using \code{\link{lm}} assuming no phylogenetic signal.  A better
approach is to run \code{link[lme4:lmer]{lmer}} and use the output
random effects for \code{s2.init}. If \code{s2.init} is not
provided for \code{family="binomial"}, these are set to 0.25.}

\item{B.init}{initial estimates of \eqn{B}{B}, a matrix containing
regression coefficients in the model for the fixed effects. This
matrix must have \code{dim(B.init)=c(p+1,1)}, where \code{p} is the
number of predictor (independent) variables; the first element of
\code{B} corresponds to the intercept, and the remaining elements
correspond in order to the predictor (independent) variables in the
formula.  If \code{B.init} is not provided, these are estimated
using in a clunky way using \code{\link{lm}} or \code{\link{glm}}
assuming no phylogenetic signal.  A better approach is to run
\code{\link[lme4:lmer]{lmer}} and use the output fixed effects for
\code{B.init}. When \code{bayes = TRUE}, initial values are estimated
using the maximum likelihood fit unless \code{ML.init = FALSE}, in
which case the default \code{INLA} initial values will be used.}

\item{reltol}{a control parameter dictating the relative tolerance
for convergence in the optimization; see \code{\link{optim}}.}

\item{maxit}{a control parameter dictating the maximum number of
iterations in the optimization; see \code{\link{optim}}.}

\item{tol.pql}{a control parameter dictating the tolerance for
convergence in the PQL estimates of the mean components of the
binomial GLMM.}

\item{maxit.pql}{a control parameter dictating the maximum number
of iterations in the PQL estimates of the mean components of the
binomial GLMM.}

\item{verbose}{if \code{TRUE}, the model deviance and running
estimates of \code{s2} and \code{B} are plotted each iteration
during optimization.}

\item{ML.init}{Only relevant if \code{bayes = TRUE}. Should maximum
likelihood estimates be calculated and used as initial values for
the bayesian model fit? Recommended when possible. Only used if
\code{family = "binomial"} or \code{family = "gaussian"}, ignored otherwise.}

\item{marginal.summ}{Summary statistic to use for the estimate of coefficients when
doing a bayesian PGLMM (when \code{bayes = TRUE}). Options are: "mean",
"median", or "mode", referring to different characterizations of the central
tendency of the bayesian posterior marginal distributions. Ignored if \code{bayes == FALSE}}

\item{calc.DIC}{Should the Deviance Informatiob Criterion be calculated and returned,
when doing a bayesian PGLMM? Ignored if \code{bayes = FALSE}}

\item{default.prior}{Which type of default prior should be used by \code{communityPGLMM}?
Only used if \code{bayes = TRUE}, ignored otherwise. There are currently two options:
"inla.default", which uses the default \code{INLA} priors, or "pc.prior", which uses a
complexity penalizing prior (as described in \href{https://arxiv.org/abs/1403.4630v3}{Simpson et al. (2017)}).
"pc.prior" is only implemented for \code{family = "gaussian"} currently.}

\item{cpp}{whether to use c++ function for optim. Default is TRUE. Ignored if
\code{bayes = TRUE}}

\item{optimizer}{bobyqa (default) or Nelder-Mead or nelder-mead-nlopt (from the nloptr package) or subplex (from the nloptr package).}

\item{x}{communityPGLMM object to be summarised}

\item{...}{additional arguments to summary and plotting functions
(currently ignored), or additional arguments to \code{\link[INLA:inla]{inla}}
when \code{bayes = TRUE}.

\deqn{Y = \beta_0 + \beta_1x + b_0 + b_1x}{y = beta_0 + beta_1x + b_0 + b_1x}
\deqn{b_0 ~ Gaussian(0, \sigma_0^2I_{sp})}{b_0 ~ Gaussian(0, sigma_0^2I_(sp))}
\deqn{b_1 ~ Gaussian(0, \sigma_0^2V_{sp})}{b_0 ~ Gaussian(0, sigma_0^2V_(sp))}
\deqn{\eta ~ Gaussian(0,\sigma^2)}{e ~ Gaussian(0,sigma^2)}

where \eqn{\beta_0}{beta_0} and \eqn{\beta_1}{beta_1} are fixed
effects, and \eqn{V_{sp}}{V_(sp)} is a variance-covariance matrix
derived from a phylogeny (typically under the assumption of
Brownian motion evolution). Here, the variation in the mean
(intercept) for each species is given by the random effect
\eqn{b_0}{b_0} that is assumed to be independent among
species. Variation in species' responses to predictor variable
\eqn{x}{x} is given by a random effect \eqn{b_0}{b_0} that is
assumed to depend on the phylogenetic relatedness among species
given by \eqn{V_{sp}}{V_(sp_}; if species are closely related,
their specific responses to \eqn{x}{x} will be similar. This
particular model would be specified as

\code{re.1 <- list(1, sp = dat$sp, covar = diag(nspp))}
\code{re.2 <- list(dat$X, sp = dat$sp, covar = Vsp)}
\code{z <- communityPGLMM(Y ~ X, data = data, family = "gaussian", random.effects = list(re.1, re.2))}

The covariance matrix covar is standardized to have its determinant
equal to 1. This in effect standardizes the interpretation of the
scalar \eqn{\sigma^2}{sigma^2}. Although mathematically this is
not required, it is a very good idea to standardize the predictor
(independent) variables to have mean 0 and variance 1. This will
make the function more robust and improve the interpretation of the
regression coefficients. For categorical (factor) predictor
variables, you will need to construct 0-1 dummy variables, and
these should not be standardized (for obvious reasons).

For binary generalized linear mixed models (\code{family =
'binomial'}), the function estimates parameters for the model of
the form, for example,

\deqn{y = \beta_0 + \beta_1x + b_0 + b_1x}{y = beta_0 + beta_1x + b_0 + b_1x}
\deqn{Y = logit^{-1}(y)}{Y = logit^(-1)(y)}
\deqn{b_0 ~ Gaussian(0, \sigma_0^2I_{sp})}{b_0 ~ Gaussian(0, sigma_0^2I_(sp))}
\deqn{b_1 ~ Gaussian(0, \sigma_0^2V_{sp})}{b_0 ~ Gaussian(0, sigma_0^2V_(sp))}

where \eqn{\beta_0}{beta_0} and \eqn{\beta_1}{beta_1} are fixed
effects, and \eqn{V_{sp}}{V_(sp)} is a variance-covariance matrix
derived from a phylogeny (typically under the assumption of
Brownian motion evolution).

\code{z <- communityPGLMM(Y ~ X, data = data, family =
'binomial', random.effects = list(re.1, re.2))}

As with the linear mixed model, it is a very good idea to
standardize the predictor (independent) variables to have mean 0
and variance 1. This will make the function more robust and improve
the interpretation of the regression coefficients. For categorical
(factor) predictor variables, you will need to construct 0-1 dummy
variables, and these should not be standardized (for obvious
reasons).}

\item{ss}{which of the \code{random.effects} to produce}

\item{digits}{minimal number of significant digits for printing, as
in \code{\link{print.default}}}

\item{show.plot}{if \code{TRUE} (default), display plot}
}
\value{
an object of class \code{communityPGLMM}
\item{formula}{the formula for fixed effects}
\item{data}{the dataset}
\item{family}{either \code{gaussian} or \code{binomial} depending on the model fit}
\item{random.effects}{the list of random effects}
\item{B}{estimates of the regression coefficients}
\item{B.se}{approximate standard errors of the fixed effects regression coefficients. This is set to NULL if \code{bayes = TRUE}.}
\item{B.ci}{approximate bayesian credible interval of the fixed effects regression coefficients. This is set to NULL if \code{bayes = FALSE}}
\item{B.cov}{approximate covariance matrix for the fixed effects regression coefficients}
\item{B.zscore}{approximate Z scores for the fixed effects regression coefficients. This is set to NULL if \code{bayes = TRUE}}
\item{B.pvalue}{approximate tests for the fixed effects regression coefficients being different from zero. This is set to NULL if \code{bayes = TRUE}}
\item{ss}{random effects' standard deviations for the covariance matrix \eqn{\sigma^2V}{sigma^2 V} for each random effect in order. For the linear mixed model, the residual variance is listed last}
\item{s2r}{random effects variances for non-nested random effects}
\item{s2n}{random effects variances for nested random effects}
\item{s2resid}{for linear mixed models, the residual variance}
\item{s2r.ci}{Bayesian credible interval for random effects variances for non-nested random effects.
This is set to NULL if \code{bayes = FALSE}}
\item{s2n.ci}{Bayesian credible interval for random effects variances for nested random effects.
This is set to NULL if \code{bayes = FALSE}}
\item{s2resid.ci}{Bayesian credible interval for linear mixed models, the residual variance.
This is set to NULL if \code{bayes = FALSE}}
\item{logLIK}{for linear mixed models, the log-likelihood for either the restricted likelihood (\code{REML=TRUE}) or the overall likelihood (\code{REML=FALSE}). This is set to NULL for generalised linear mixed models. If \code{bayes = TRUE}, this is the marginal log-likelihood}
\item{AIC}{for linear mixed models, the AIC for either the restricted likelihood (\code{REML=TRUE}) or the overall likelihood (\code{REML=FALSE}). This is set to NULL for generalised linear mixed models}
\item{BIC}{for linear mixed models, the BIC for either the restricted likelihood (\code{REML=TRUE}) or the overall likelihood (\code{REML=FALSE}). This is set to NULL for generalised linear mixed models}
\item{DIC}{for bayesian PGLMM, this is the Deviance Information Criterion metric of model fit. This is set to NULL if \code{bayes = FALSE}.}
\item{REML}{whether or not REML is used (\code{TRUE} or \code{FALSE}).}
\item{bayes}{whether or not a Bayesian model was fit.}
\item{marginal.summ}{The specified summary statistic used to summarise the Bayesian marginal distributions.
Only present if \code{bayes = TRUE}}
\item{s2.init}{the user-provided initial estimates of \code{s2}}
\item{B.init}{the user-provided initial estimates of \code{B}}
\item{Y}{the response (dependent) variable returned in matrix form}
\item{X}{the predictor (independent) variables returned in matrix form (including 1s in the first column)}
\item{H}{the residuals. For the generalized linear mixed model, these are the predicted residuals in the \eqn{logit^{-1}}{logit -1} space}
\item{iV}{the inverse of the covariance matrix for the entire system (of dimension (nsp\emph{nsite) by (nsp}nsite)).
This is NULL is code{bayes = TRUE}}
\item{mu}{predicted mean values for the generalized linear mixed model. Set to NULL for linear mixed models}
\item{sp, sp}{matrices used to construct the nested design matrix.}
\item{Zt}{the design matrix for random effects}
\item{St}{diagonal matrix that maps the random effects variances onto the design matrix}
\item{convcode}{the convergence code provided by \code{\link{optim}}. This is set to NULL if \code{bayes = TRUE}}
\item{niter}{number of iterations performed by \code{\link{optim}}. This is set to NULL if \code{bayes = TRUE}}
\item{inla.model}{Model object fit by underlying \code{\link{inla}} function. Only returned
if \code{bayes = TRUE}}
}
\description{
This function performs Generalized Linear Mixed Models for binary
and continuous phylogenetic data, estimating regression
coefficients with approximate standard errors. It is modeled after
\code{\link[lme4:lmer]{lmer}} but is more general by allowing
correlation structure within random effects; these correlations can
be phylogenetic among species, or any other correlation structure,
such as geographical correlations among sites. It is, however, much
more specific than \code{\link[lme4:lmer]{lmer}} in that it can
only analyze a subset of1 the types of model designed handled by
\code{\link[lme4:lmer]{lmer}}. It is also much slower than
\code{\link[lme4:lmer]{lmer}} and requires users to specify
correlation structures as covariance
matrices. \code{communityPGLMM} can analyze models in Ives and
Helmus (2011). It can also analyze bipartite phylogenetic data,
such as that analyzed in Rafferty and Ives (2011), by giving sites
phylogenetic correlations. A Bayesian version of PGLMM can be fit by
specifying the \code{bayes = TRUE}. This uses the package \code{\link[INLA:INLA-package]{INLA}}
package, which is not available on cran. If you wish to use this option,
you must first install \code{INLA} from \url{http://www.r-inla.org/}.
Note that when \code{bayes = TRUE}, the \code{family} parameter allows
additional arguments besides \code{"gaussian"} and \code{"binomial"}.
For a full list see \code{names(INLA::inla.models()$likelihood)}. Note:
The bayesian version currently does not support random slopes, only random
intercepts, for both i.i.d. and correlation structure random effects. Support
for uncorrelated random slopes will be implemented soon.

\code{communityPGLMM.binary} calculates the statistical
significance of the random effects in the generalized linear mixed
model from the marginal profile likelihood.

\code{communityPGLMM.binary.LRT} tests statistical significance of
the phylogenetic random effect on species slopes using a likelihood
ratio test

\code{communityPGLMM.matrix.structure} produces the entire
covariance matrix structure (V) when you specify random effects.

\code{communityPGLMM.predicted.values} calculates the predicted
values of Y; for the generalized linear mixed model (family =
"binomial"), these values are in the logit-1 transformed space.
}
\note{
These function \emph{do not} use a
\code{\link{comparative.comm}} object, but you can use
\code{\link{as.data.frame.comparative.comm}} to
create a \code{data.frame} for use with these functions. The power
of this method comes from deciding your own parameters parameters
to be determined (the data for regression, the random effects,
etc.), and it is our hope that this interface gives you more
flexibility in model selection/fitting.
}
\examples{
## Structure of examples:
# First, a (brief) description of model types, and how they are specified
# - these are *not* to be run 'as-is'; they show how models should be organised
# Second, a run-through of how to simulate, and then analyse, data
# - these *are* to be run 'as-is'; they show how to format and work with data

\dontrun{
#########################################################
#First section; brief summary of models and their use####
#########################################################
## Model structures from Ives & Helmus (2011)
# dat = data set for regression (note: *not* an comparative.comm object)
# phy = phylogeney of class "phylo"
# repulsion = to test phylogenetic repulsion or not

# Model 1 (Eq. 1)
z <- communityPGLMM(freq ~ sp + (1|site) + (1|sp@site), data = dat, family = "binomial", 
                   tree = phy, REML = TRUE, verbose = TRUE, s2.init=.1)

# Model 2 (Eq. 2)
z <- communityPGLMM(freq ~ sp + X + (1|site) + (X|sp__), data = dat, family = "binomial",
                    tree = phy, REML = TRUE, verbose = TRUE, s2.init=.1)

# Model 3 (Eq. 3)
z <- communityPGLMM(freq ~ sp*X + (1|site) + (1|sp@site), data = dat, family = "binomial",
                    tree = phy, REML = TRUE, verbose = TRUE, s2.init=.1)

## Model structure from Rafferty & Ives (2013) (Eq. 3)
# dat = data set
# nspp = number of pollinators (sp)
# nsite = number of plants (site)
# phyPol = phylogeny for pollinators
# phyPlt = phylogeny for plants

# prepare random effects
re12 = c(re1, re2)

z <- communityPGLMM(freq ~ sp*X, data = dat, family = "binomial",
 random.effects = re12, REML = TRUE, verbose = TRUE, s2.init=.1)
}

#########################################################
#Second section; detailed simulation and analysis #######
#########################################################
# Generate simulated data for nspp species and nsite sites
nspp <- 15
nsite <- 10

# residual variance (set to zero for binary data)
sd.resid <- 0

# fixed effects
beta0 <- 0
beta1 <- 0

# magnitude of random effects
sd.B0 <- 1
sd.B1 <- 1

# whether or not to include phylogenetic signal in B0 and B1
signal.B0 <- TRUE
signal.B1 <- TRUE

# simulate a phylogenetic tree
phy <- rtree(n = nspp)
phy <- compute.brlen(phy, method = "Grafen", power = 0.5)

# standardize the phylogenetic covariance matrix to have determinant 1
Vphy <- vcv(phy)
Vphy <- Vphy/(det(Vphy)^(1/nspp))

# Generate environmental site variable
X <- matrix(1:nsite, nrow = 1, ncol = nsite)
X <- (X - mean(X))/sd(X)

# Perform a Cholesky decomposition of Vphy. This is used to
# generate phylogenetic signal: a vector of independent normal random
# variables, when multiplied by the transpose of the Cholesky
# deposition of Vphy will have covariance matrix equal to Vphy.

iD <- t(chol(Vphy))

# Set up species-specific regression coefficients as random effects
if (signal.B0 == TRUE) {
		b0 <- beta0 + iD \%*\% rnorm(nspp, sd = sd.B0)
} else {
		b0 <- beta0 + rnorm(nspp, sd = sd.B0)
}
if (signal.B1 == TRUE) {
		b1 <- beta1 + iD \%*\% rnorm(nspp, sd = sd.B1)
} else {
		b1 <- beta1 + rnorm(nspp, sd = sd.B1)
}

# Simulate species abundances among sites to give matrix Y that
# contains species in rows and sites in columns
y <- rep(b0, each=nsite)
y <- y + rep(b1, each=nsite) * rep(X, nspp)
y <- y + rnorm(nspp*nsite) #add some random 'error'
Y <- rbinom(length(y), size=1, prob=exp(y)/(1+exp(y)))
y <- matrix(outer(b0, array(1, dim = c(1, nsite))), nrow = nspp,
ncol = nsite) + matrix(outer(b1, X), nrow = nspp, ncol = nsite)
e <- rnorm(nspp * nsite, sd = sd.resid)
y <- y + matrix(e, nrow = nspp, ncol = nsite)
y <- matrix(y, nrow = nspp * nsite, ncol = 1)

Y <- rbinom(n = length(y), size = 1, prob = exp(y)/(1 + exp(y)))
Y <- matrix(Y, nrow = nspp, ncol = nsite)

# name the simulated species 1:nspp and sites 1:nsites
rownames(Y) <- 1:nspp
colnames(Y) <- 1:nsite

par(mfrow = c(3, 1), las = 1, mar = c(2, 4, 2, 2) - 0.1)
matplot(t(X), type = "l", ylab = "X", main = "X among sites")
hist(b0, xlab = "b0", main = "b0 among species")
hist(b1, xlab = "b1", main = "b1 among species")

#Plot out; you get essentially this from plot(your.pglmm.model)
image(t(Y), ylab = "species", xlab = "sites", main = "abundance",
col=c("black","white"))

# Transform data matrices into "long" form, and generate a data frame
YY <- matrix(Y, nrow = nspp * nsite, ncol = 1)

XX <- matrix(kronecker(X, matrix(1, nrow = nspp, ncol = 1)), nrow =
nspp * nsite, ncol = 1)

site <- matrix(kronecker(1:nsite, matrix(1, nrow = nspp, ncol =
1)), nrow = nspp * nsite, ncol = 1)
sp <- matrix(kronecker(matrix(1, nrow = nsite, ncol = 1), 1:nspp),
nrow = nspp * nsite, ncol = 1)

dat <- data.frame(Y = YY, X = XX, site = as.factor(site), sp = as.factor(sp))

# Format input and perform communityPGLMM()
# set up random effects

# random intercept with species independent
re.1 <- list(1, sp = dat$sp, covar = diag(nspp))

# random intercept with species showing phylogenetic covariances
re.2 <- list(1, sp = dat$sp, covar = Vphy)

# random slope with species independent
re.3 <- list(dat$X, sp = dat$sp, covar = diag(nspp))

# random slope with species showing phylogenetic covariances
re.4 <- list(dat$X, sp = dat$sp, covar = Vphy)

# random effect for site
re.site <- list(1, site = dat$site, covar = diag(nsite))

simple <- communityPGLMM(Y ~ X, data = dat, family = "binomial", sp
= dat$sp, site = dat$site, random.effects = list(re.site),
REML=TRUE, verbose=FALSE)

# The rest of these tests are not run to save CRAN server time;
# - please take a look at them because they're *very* useful!
\dontrun{ 
z.binary <- communityPGLMM(Y ~ X, data = dat, family = "binomial",
sp = dat$sp, site = dat$site, random.effects = list(re.1, re.2,
re.3, re.4), REML = TRUE, verbose = FALSE)

# output results
z.binary
plot(z.binary)

# test statistical significance of the phylogenetic random effect
# on species slopes using a likelihood ratio test
communityPGLMM.binary.LRT(z.binary, re.number = 4)$Pr

# extract the predicted values of Y
communityPGLMM.predicted.values(z.binary, show.plot = TRUE)

# examine the structure of the overall covariance matrix
communityPGLMM.matrix.structure(Y ~ X, data = dat, family =
"binomial", sp = dat$sp, site = dat$site, random.effects =
list(re.1, re.2, re.3, re.4))

# look at the structure of re.1
communityPGLMM.matrix.structure(Y ~ X, data = dat, family =
"binomial", sp = dat$sp, site = dat$site, random.effects =
list(re.1))

# compare results to glmer() when the model contains no
# phylogenetic covariance among species; the results should be
# similar.
communityPGLMM(Y ~ X, data = dat, family = "binomial", sp = dat$sp,
site = dat$site, random.effects = list(re.1, re.3), REML = FALSE,
verbose = FALSE)

# lmer
if(require(lme4)){
summary(glmer(Y ~ X + (1 | sp) + (0 + X | sp), data=dat, family =
"binomial"))

# compare results to lmer() when the model contains no phylogenetic
# covariance among species; the results should be similar.
communityPGLMM(Y ~ X, data = dat, family = "gaussian", sp = dat$sp,
site = dat$site, random.effects = list(re.1, re.3), REML = FALSE,
verbose = FALSE)

# lmer
summary(lmer(Y ~ X + (1 | sp) + (0 + X | sp), data=dat, REML = FALSE))
}
}
}
\references{
Ives, A. R. and M. R. Helmus. 2011. Generalized linear
mixed models for phylogenetic analyses of community
structure. Ecological Monographs 81:511-525.

Rafferty, N. E., and A. R. Ives. 2013. Phylogenetic
trait-based analyses of ecological networks. Ecology 94:2321-2333.

Simpson, Daniel, et al. "Penalising model component complexity:
A principled, practical approach to constructing priors."
Statistical science 32.1 (2017): 1-28.
}
\author{
Anthony R. Ives
}
