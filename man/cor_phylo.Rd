% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cor_phylo.R
\name{cor_phylo}
\alias{cor_phylo}
\alias{boot_ci.cor_phylo}
\alias{print.cor_phylo}
\title{Correlations among multiple traits with phylogenetic signal}
\usage{
cor_phylo(traits, species, phy,
          covariates = list(),
          meas_errors = list(),
          data = sys.frame(sys.parent()),
          REML = TRUE, 
          method = c("nelder-mead-nlopt", "bobyqa",
              "subplex", "nelder-mead-r", "sann"),
          constrain_d = FALSE,
          rel_tol = 1e-6,
          max_iter = 1000,
          sann_options = list(),
          verbose = FALSE,
          boot = 0,
          keep_boots = c("fail", "none", "all"))

\method{boot_ci}{cor_phylo}(mod, refits = NULL, alpha = 0.05, ...)

\method{print}{cor_phylo}(x, digits = max(3, getOption("digits") - 3),
  ...)
}
\arguments{
\item{traits}{A list of object names or a matrix that contains trait values.
In the former case, the list must be of length \code{p}, one name for each trait,
and each name must must refer to an object in \code{data}.
See "Using names" in the Details for more info on using names.
In the latter case, the matrix must have \code{n} rows and \code{p} columns;
if the matrix columns aren't named, \code{cor_phylo} will name them \code{par_1 ... par_p}.}

\item{species}{An object-name or a vector that indicates the species.
In the former case, see "Using names" in the Details for more info on using names.
In the latter case, the vector must be of the same type as the input
phylogeny's tip labels.}

\item{phy}{A \code{phylo} object giving the phylogenetic tree.}

\item{covariates}{A list containing covariate(s) for each trait.
The list can contain only names (see "Using names" in Details),
matrices, or \code{NULL} and can be assembled in one of two ways:
\enumerate{
\item Named items. Each name in the list should correspond to a name
in the traits matrix that is built from the \code{traits} argument.
So if you use a list of names in the \code{traits} argument, these names should
be used here.
If you use a matrix in the \code{traits} argument, column names should be used here.
You can simply omit names with no covariates instead of using \code{NULL} items.
\item Ordered items. The list must be of length \code{p}, each item referring to the
trait at that location in the matrix built from the \code{traits} argument.
The trait order is same as in either the list or matrix input to the \code{traits}
argument.
To indicate that a trait doesn't have a covariate, the corresponding
item in this list should be \code{NULL}.
}
If specifying more than one covariate, use \code{cbind()} rather than \code{c()};
the latter concatenates them into a too-long vector (see Examples).
If these aren't named, \code{cor_phylo} will name them \code{cov_1 ... cov_q}, where
\code{q} is the total number of covariates.
Defaults to \code{list()}, which indicates no covariates.}

\item{meas_errors}{A list containing measurement error for each trait.
This argument can be built in the same way as for the \code{covariates} argument
(except that you can't have multiple measurement errors for a single trait).
You can additionally pass an \code{n} x \code{p} matrix with each column associated
with the trait in the same position; if using a matrix, you can make a trait
not have measurement error by making its associated column contain only zeros.
Defaults to \code{list()}, which indicates no measurement errors.}

\item{data}{An optional data frame, list, or environment that contains the
variables in the model. By default, variables are taken from the environment
from which \code{cor_phylo} was called.}

\item{REML}{Whether REML (versus ML) should be used for model fitting.
Defaults to \code{TRUE}.}

\item{method}{Method of optimization using \code{nlopt} or \code{\link[stats]{optim}}.
Options include \code{"nelder-mead-nlopt"}, \code{"bobyqa"}, \code{"subplex"}, \code{"nelder-mead-r"},
and \code{"sann"}.
The first three are carried out by \code{nlopt}, and the latter two by
\code{\link[stats]{optim}}.
See \url{https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/} for information
on the \code{nlopt} algorithms.
Defaults to \code{"nelder-mead-nlopt"}.}

\item{constrain_d}{If \code{constrain_d} is \code{TRUE}, the estimates of \code{d} are
constrained to be between zero and 1. This can make estimation more stable and
can be tried if convergence is problematic. This does not necessarily lead to
loss of generality of the results, because before using \code{cor_phylo},
branch lengths of \code{phy} can be transformed so that the "starter" tree
has strong phylogenetic signal.
Defaults to \code{FALSE}.}

\item{lower_d}{Lower bound on the phylogenetic signal parameter.
Defaults to \code{1e-7}.}

\item{rel_tol}{A control parameter dictating the relative tolerance for convergence
in the optimization. Defaults to \code{1e-6}.}

\item{max_iter}{A control parameter dictating the maximum number of iterations
in the optimization. Defaults to \code{1000}.}

\item{sann_options}{A named list containing the control parameters for SANN
minimization.
This is only relevant if \code{method == "sann"}.
This list can only contain the names \code{"maxit"}, \code{"temp"}, and/or \code{"tmax"},
which will control the maximum number of iterations,
starting temperature, and number of function evaluations at each temperature,
respectively.
Defaults to \code{list()}, which results in \code{maxit = 1000}, \code{temp = 1}, and \code{tmax = 1}.
Note that these are different from the defaults for \code{\link[stats]{optim}}.}

\item{verbose}{If \code{TRUE}, the model \code{logLik} and running estimates of the
correlation coefficients and values of \code{d} are printed each iteration
during optimization. Defaults to \code{FALSE}.}

\item{rcond_threshold}{Threshold for the reciprocal condition number of two
matrices inside the log likelihood function.
Increasing this threshold makes the optimization process more strongly
"bounce away" from badly conditioned matrices and can help with convergence
and with estimates that are nonsensical.
Defaults to \code{1e-10}.}

\item{boot}{Number of parametric bootstrap replicates. Defaults to \code{0}.}

\item{keep_boots}{Character specifying when to output data (indices, convergence codes,
and simulated trait data) from bootstrap replicates.
This is useful for troubleshooting when one or more bootstrap replicates
fails to converge or outputs ridiculous results.
Setting this to \code{"all"} keeps all \code{boot} parameter sets,
\code{"fail"} keeps parameter sets from replicates that failed to converge,
and \code{"none"} keeps no parameter sets.
Defaults to \code{"fail"}.}

\item{mod}{\code{cor_phylo} object that was run with the \code{boot} argument > 0.}

\item{refits}{One or more \code{cp_refits} objects containing refits of \code{cor_phylo}
bootstrap replicates. These are used when the original fit did not converge.
Multiple \code{cp_refits} objects should be input as a list.
For a given bootstrap replicate, the original fit's estimates will be used
when the fit converged.
If multiple \code{cp_refits} objects are input and more than one converged for a given
replicate, the estimates from the first \code{cp_refits} object containg a converged
fit for that replicate will be used.
Defaults to \code{NULL}.}

\item{alpha}{Alpha used for the confidence intervals. Defaults to \code{0.05}.}

\item{...}{arguments passed to and from other methods.}

\item{x}{an object of class \code{cor_phylo}.}

\item{digits}{the number of digits to be printed.}
}
\value{
\code{cor_phylo} returns an object of class \code{cor_phylo}:
\item{\code{call}}{The matched call.}
\item{\code{corrs}}{The \code{p} x \code{p} matrix of correlation coefficients.}
\item{\code{d}}{Values of \code{d} from the OU process for each trait.}
\item{\code{B}}{A matrix of regression-coefficient estimates, SE, Z-scores, and P-values,
respectively. Rownames indicate which coefficient it refers to.}
\item{\code{B_cov}}{Covariance matrix for regression coefficients.}
\item{\code{logLik}}{The log likelihood for either the restricted likelihood
(\code{REML = TRUE}) or the overall likelihood (\code{REML = FALSE}).}
\item{\code{AIC}}{AIC for either the restricted likelihood (\code{REML = TRUE}) or the
overall likelihood (\code{REML = FALSE}).}
\item{\code{BIC}}{BIC for either the restricted likelihood (\code{REML = TRUE}) or the
overall likelihood (\code{REML = FALSE}).}
\item{\code{niter}}{Number of iterations the optimizer used.}
\item{\code{convcode}}{Conversion code for the optimizer.
This number is \code{0} on success and positive on failure.
\describe{
\item{1}{iteration limit reached}
\item{2}{generic failure code (nlopt optimizers only).}
\item{3}{invalid arguments (nlopt optimizers only).}
\item{4}{out of memory (nlopt optimizers only).}
\item{5}{roundoff errors limited progress (nlopt optimizers only).}
\item{6}{user-forced termination (nlopt optimizers only).}
\item{10}{degeneracy of the Nelder-Mead simplex (\code{stats::optim} only).}
}
For more information on the nlopt return codes, see
\url{https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values}.}
\item{\code{rcond_vals}}{Reciprocal condition numbers for two matrices inside
the log likelihood function. These are provided to potentially help guide
the changing of the \code{rcond_threshold} parameter.}
\item{\code{bootstrap}}{A list of bootstrap output, which is simply \code{list()} if
\code{boot = 0}. If \code{boot > 0}, then the list contains fields for
estimates of correlations (\code{corrs}), phylogenetic signals (\code{d}),
coefficients (\code{B0}), and coefficient covariances (\code{B_cov}).
It also contains the following information about the bootstrap replicates:
a vector of indices relating each set of information to the bootstrapped
estimates (\code{inds}),
convergence codes (\code{convcodes}), and
matrices of the bootstrapped parameters in the order they appear in the input
argument (\code{mats});
these three fields will be empty if \code{keep_boots == "none"}.
To view bootstrapped confidence intervals, use \code{boot_ci}.}

\code{boot_ci} returns a list of confidence intervals with the following fields:
\describe{
\item{\code{corrs}}{
Estimates of correlations.
This is a matrix the values above the diagonal being the
upper limits and values below being the lower limits.}
\item{\code{d}}{Phylogenetic signals.}
\item{\code{B0}}{Coefficient estimates.}
\item{\code{B_cov}}{Coefficient covariances.}
}
}
\description{
This function calculates Pearson correlation coefficients for multiple continuous
traits that may have phylogenetic signal, allowing users to specify measurement
error as the standard error of trait values at the tips of the phylogenetic tree.
Phylogenetic signal for each trait is estimated from the data assuming that trait
evolution is given by a Ornstein-Uhlenbeck process.  Thus, the function allows the
estimation of phylogenetic signal in multiple traits while incorporating
correlations among traits. It is also possible to include independent variables
(covariates) for each trait to remove possible confounding effects.
\code{cor_phylo} returns the correlation matrix for trait values, estimates
of phylogenetic signal for each trait, and regression coefficients for
independent variables affecting each trait.
}
\section{Methods (by generic)}{
\itemize{
\item \code{boot_ci}: returns bootstrapped confidence intervals from a \code{cor_phylo} object

\item \code{print}: prints \code{cor_phylo} objects
}}

\section{Using names}{

The arguments \code{traits}, \code{species}, \code{covariates}, and \code{meas_errors} can use names
that exist inside the \code{data} argument instead of using objects directly.
For instance, if \code{data} is a data frame with column names \code{x} and \code{y}, but
you have not defined any objects named \code{x} or \code{y} anywhere else, you can still
use \code{cor_phylo(traits = list(x, y), ...)} without quotes (quotes work, too).

It's also important to note that you should use names for all of these arguments
or none of them. That's because if a name isn't present in the \code{data} environment,
you may get errors.
Sometimes it works anyway, but I don't recommend it.
See \code{\link[base]{eval}} for more info.
}

\section{Walkthrough}{

For the case of two variables, the function estimates parameters for the model of
the form, for example,

\deqn{X[1] =  B[1,0] + B[1,1] * u[1,1] + \epsilon[1]}
\deqn{X[2] =  B[2,0] + B[2,1] * u[2,1] + \epsilon[2]}
\deqn{\epsilon ~ Gaussian(0, V) }

where \eqn{B[1,0]}, \eqn{B[1,1]}, \eqn{B[2,0]}, and \eqn{B[2,1]} are regression
coefficients, and \eqn{V} is a variance-covariance matrix containing the correlation
coefficient r, parameters of the OU process \eqn{d1} and \eqn{d2}, and diagonal
matrices \eqn{M1} and \eqn{M2} of measurement standard errors for \eqn{X[1]} and
\eqn{X[2]}. The matrix \eqn{V} is \eqn{2n x 2n}, with \eqn{n x n} blocks given by

\deqn{V[1,1] = C[1,1](d1) + M1}
\deqn{V[1,2] = C[1,2](d1,d2)}
\deqn{V[2,1] = C[2,1](d1,d2)}
\deqn{V[2,2] = C[2,2](d2) + M2}

where \eqn{C[i,j](d1,d2)} are derived from \code{phy} under the assumption of joint
OU evolutionary processes for each trait (see Zheng et al. 2009). This formulation
extends in the obvious way to more than two traits.
}

\examples{

## Simple example using data without correlations or phylogenetic
## signal. This illustrates the structure of the input data.

set.seed(10)
phy <- ape::rcoal(10, tip.label = 1:10)
data_df <- data.frame(
    species = phy$tip.label,
    # traits:
    par1 = rnorm(10),
    par2 = rnorm(10),
    par3 = rnorm(10),
    # covariate for par2:
    cov2 = rnorm(10, mean = 10, sd = 4),
    # measurement error for par1 and par2, respectively:
    se1 = 0.2,
    se2 = 0.4
)
data_df$par2 <- data_df$par2 + 0.5 * data_df$cov2

# `cor_phylo` allows for data to be input in multiple ways

# Using names and named lists:
cor_phylo(traits = list(par1, par2, par3),
          species = species, phy = phy,
          covariates = list(par2 = cov2),
          meas_errors = list(par1 = se1, par2 = se2),
          data = data_df)
# Instead using strings and non-named lists:
cor_phylo(traits = list("par1", "par2", "par3"),
          species = "species", phy = phy,
          covariates = list(NULL, "cov2", NULL),
          meas_errors = list("se1", "se2", NULL),
          data = data_df)
# Combine the methods above:
cor_phylo(traits = list(par1, "par2", par3),
          species = "species", phy = phy,
          covariates = list(par2 = cov2),
          meas_errors = list("se1", se2, NULL),
          data = data_df)

# If you've already created matrices...
X <- as.matrix(data_df[,c("par1", "par2", "par3")])
U <- list(NULL,
          as.matrix(data_df[, "cov2", drop = FALSE]),
          NULL)
M <- cbind(data_df$se1, data_df$se2, rep(0, 10))

# ... you can also use those directly
# (notice that I'm inputting an object for `species`
# bc I ommitted `data`):
cor_phylo(traits = X, species = data_df$species,
          phy = phy, covariates = U,
          meas_errors = M)

# I do not recommend mixing matrix and list input methods.



\dontrun{

## Simulation example for the correlation between two variables. The example
## compares the estimates of the correlation coefficients from cor_phylo when
## measurement error is incorporated into the analyses with three other cases:
## (i) when measurement error is excluded, (ii) when phylogenetic signal is
## ignored (assuming a "star" phylogeny), and (iii) neither measurement error
## nor phylogenetic signal are included.

# In the simulations, variable 2 is associated with a single independent variable.

library(ape)

set.seed(1)
# Set up parameter values for simulating data
n <- 50
phy <- rcoal(n, tip.label = 1:n)

R <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
d <- c(0.3, 0.95)
B2 <- 1

Se <- c(0.2, 1)
M <- matrix(Se, nrow = n, ncol = 2, byrow = TRUE)

# Set up needed matrices for the simulations
p <- length(d)

star <- stree(n)
star$edge.length <- array(1, dim = c(n, 1))
star$tip.label <- phy$tip.label

Vphy <- vcv(phy)
Vphy <- Vphy/max(Vphy)
Vphy <- Vphy/exp(determinant(Vphy)$modulus[1]/n)

tau <- matrix(1, nrow = n, ncol = 1) \%*\% diag(Vphy) - Vphy
C <- matrix(0, nrow = p * n, ncol = p * n)
for (i in 1:p) for (j in 1:p) {
  Cd <- (d[i]^tau * (d[j]^t(tau)) * (1 - (d[i] * d[j])^Vphy))/(1 - d[i] * d[j])
  C[(n * (i - 1) + 1):(i * n), (n * (j - 1) + 1):(j * n)] <- R[i, j] * Cd
}
MM <- matrix(M^2, ncol = 1)
V <- C + diag(as.numeric(MM))

# Perform a Cholesky decomposition of Vphy. This is used to generate phylogenetic
# signal: a vector of independent normal random variables, when multiplied by the
# transpose of the Cholesky deposition of Vphy will have covariance matrix
# equal to Vphy.
iD <- t(chol(V))

# Perform Nrep simulations and collect the results
Nrep <- 100
cor.list <- matrix(0, nrow = Nrep, ncol = 1)
cor.noM.list <- matrix(0, nrow = Nrep, ncol = 1)
cor.noP.list <- matrix(0, nrow = Nrep, ncol = 1)
cor.noMP.list <- matrix(0, nrow = Nrep, ncol = 1)
d.list <- matrix(0, nrow = Nrep, ncol = 2)
d.noM.list <- matrix(0, nrow = Nrep, ncol = 2)
B.list <- matrix(0, nrow = Nrep, ncol = 3)
B.noM.list <- matrix(0, nrow = Nrep, ncol = 3)
B.noP.list <- matrix(0, nrow = Nrep, ncol = 3)

set.seed(2)
for (rep in 1:Nrep) {
  
  XX <- iD \%*\% rnorm(2 * n)
  X <- matrix(XX, n, p)
  
  U <- list(NULL, cbind(rnorm(n, mean = 2, sd = 10)))
  
  X[,2] <- X[,2] + B2[1] * U[[2]][,1] - B2[1] * mean(U[[2]][,1])
  
  # Call cor_phylo with (i) phylogeny and measurement error,
  # (ii) just phylogeny,
  # and (iii) just measurement error
  z <- cor_phylo(traits = X,
                 covariates = U,
                 meas_errors = M,
                 phy = phy,
                 species = phy$tip.label)
  z.noM <- cor_phylo(traits = X,
                     covariates = U,
                     phy = phy,
                     species = phy$tip.label)
  z.noP <- cor_phylo(traits = X,
                     covariates = U,
                     meas_errors = M,
                     phy = star,
                     species = phy$tip.label)
  
  cor.list[rep] <- z$corrs[1, 2]
  cor.noM.list[rep] <- z.noM$corrs[1, 2]
  cor.noP.list[rep] <- z.noP$corrs[1, 2]
  cor.noMP.list[rep] <- cor(cbind(
    lm(X[,1] ~ 1)$residuals,
    lm(X[,2] ~ U[[2]])$residuals))[1,2]
  
  d.list[rep, ] <- z$d
  d.noM.list[rep, ] <- z.noM$d
  
  B.list[rep, ] <- z$B[,1]
  B.noM.list[rep, ] <- z.noM$B[,1]
  B.noP.list[rep, ] <- z.noP$B[,1]
}

correlation <- rbind(R[1, 2], mean(cor.list), mean(cor.noM.list),
                     mean(cor.noP.list), mean(cor.noMP.list))
rownames(correlation) <- c("True", "With M and Phy", "Without M",
                           "Without Phy", "Without Phy or M")

signal.d <- rbind(d, colMeans(d.list), colMeans(d.noM.list))
rownames(signal.d) <- c("True", "With M and Phy", "Without M")

est.B <- rbind(c(0, 0, B2), colMeans(B.list),
               colMeans(B.noM.list[-39,]),  # 39th rep didn't converge
               colMeans(B.noP.list))
rownames(est.B) <- c("True", "With M and Phy", "Without M", "Without Phy")
colnames(est.B) <- rownames(z$B)

# Example simulation output:

correlation
#                       [,1]
# True             0.7000000
# With M and Phy   0.6981450
# Without M        0.2975294
# Without Phy      0.3715866
# Without Phy or M 0.3291473

signal.d
#                     [,1]      [,2]
# True           0.3000000 0.9500000
# With M and Phy 0.3061470 0.9418049
# Without M      0.2406226 0.4013869

est.B
#                     par_1_0   par_2_0 par_2_cov_1
# True            0.000000000 0.0000000   1.0000000
# With M and Phy -0.008688085 0.1093656   0.9996199
# Without M      -0.008542294 0.1146948   0.9982382
# Without Phy     0.002933341 0.1096578   1.0028482
    
}


}
\references{
Zheng, L., A. R. Ives, T. Garland, B. R. Larget, Y. Yu, and K. F. Cao.
2009. New multivariate tests for phylogenetic signal and trait correlations
applied to ecophysiological phenotypes of nine \emph{Manglietia} species.
\emph{Functional Ecology} \bold{23}:1059--1069.
}
\author{
Anthony R. Ives, Lucas A. Nell
}
\keyword{regression}
