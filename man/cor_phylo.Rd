% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cor_phylo.R
\name{cor_phylo}
\alias{cor_phylo}
\alias{boot_ci.cor_phylo}
\alias{print.cor_phylo}
\title{Correlations among multiple traits with phylogenetic signal}
\usage{
cor_phylo(formulas, species, phy, data = sys.frame(sys.parent()),
  REML = TRUE, method = c("neldermead", "bobyqa", "sbplx", "cobyla",
  "praxis", "neldermead-r", "sann-r"), constrain_d = FALSE, rel_tol = 1e-06,
  max_iter = 1000, maxit_SA = 1000, temp_SA = 1, tmax_SA = 1,
  verbose = FALSE, boot = 0, keep_boots = c("fail", "none", "all"))

\method{boot_ci}{cor_phylo}(x, alpha = 0.05)

\method{print}{cor_phylo}(x, digits = max(3, getOption("digits") - 3), ...)
}
\arguments{
\item{formulas}{a list of \code{p} formulas (class \code{\link{formula}}),
one formula for each trait of interest. Formulas should take one of the following
forms:
\describe{
\item{\code{trait ~ 1}}{traits without covariates or measurement error}
\item{\code{trait ~ covariate_1 + ... + covariate_N}}{
traits with \code{N} covariates
}
\item{\code{trait ~ 1 | measurement error}}{
traits with measurement error indicated by standard errors in
the \code{measurement error} column/vector
}
\item{\code{trait ~ covariate_1 + ... + covariate_N | measurement error}}{
traits with both covariates and measurement error
}
}}

\item{species}{The column name or object in \code{data} that indicates the species.
You do not need to use quotes for this argument,
but quotes will not adversely affect the outcome.}

\item{phy}{A \code{phylo} object giving the phylogenetic tree.}

\item{data}{An optional data frame, list, or environment that contains the
variables in the model. By default, variables are taken from the environment
from which \code{cor_phylo} was called.}

\item{REML}{Whether REML (versus ML) should be used for model fitting.
Defaults to \code{TRUE}.}

\item{method}{Method of optimization using \code{nlopt} or \code{\link[stats]{optim}}.
Options include \code{"neldermead"}, \code{"bobyqa"}, \code{"sbplx"}, \code{"cobyla"},  \code{"praxis"},
\code{"neldermead-r"}, and \code{"sann-r"}.
The first five are carried out by nlopt, and the latter two by
\code{\link[stats]{optim}}.
See \url{https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/} for information
on the nlopt algorithms.
Defaults to \code{"neldermead"}.}

\item{constrain_d}{If \code{constrain_d} is \code{TRUE}, the estimates of \code{d} are
constrained to be between zero and 1. This can make estimation more stable and
can be tried if convergence is problematic. This does not necessarily lead to
loss of generality of the results, because before using \code{cor_phylo},
branch lengths of \code{phy} can be transformed so that the "starter" tree
has strong phylogenetic signal.
Defaults to \code{FALSE}.}

\item{rel_tol}{A control parameter dictating the relative tolerance for convergence
in the optimization. Defaults to \code{1e-6}.}

\item{max_iter}{A control parameter dictating the maximum number of iterations
in the optimization. Defaults to \code{1000}.}

\item{maxit_SA}{A control parameter dictating the maximum number of iterations in the
optimization with SANN minimization; see \code{\link[stats]{optim}}.
Only relevant if \code{method == "sann"}. Defaults to \code{1000}.}

\item{temp_SA}{A control parameter dictating the starting temperature in the
optimization with SANN minimization; see \code{\link[stats]{optim}}.
Only relevant if \code{method == "sann"}. Defaults to \code{1}.}

\item{tmax_SA}{A control parameter dictating the number of function evaluations
at each temperature in the optimization with SANN minimization; see
\code{\link[stats]{optim}}. Only relevant if \code{method == "sann"}. Defaults to \code{1}.}

\item{verbose}{If \code{TRUE}, the model \code{logLik} and running estimates of the
correlation coefficients and values of \code{d} are printed each iteration
during optimization. Defaults to \code{FALSE}.}

\item{boot}{Number of parametric bootstrap replicates. Defaults to \code{0}.}

\item{keep_boots}{Character specifying when to output data (indices, convergence codes,
and simulated parametric data) from bootstrap replicates.
This is useful for troubleshooting when one or more bootstrap replicates
fails to converge or outputs ridiculous results.
Setting this to \code{"all"} keeps all \code{boot} parameter sets,
\code{"fail"} keeps parameter sets from replicates that failed to converge,
and \code{"none"} keeps no parameter sets.
Defaults to \code{"fail"}.}

\item{x}{\code{cor_phylo} object that was run with the \code{boot} argument > 0.}

\item{alpha}{Alpha used for the confidence intervals. Defaults to \code{0.05}.}

\item{digits}{the number of digits to be printed.}

\item{...}{arguments passed to and from other methods.}

\item{x}{an object of class \code{cor_phylo}.}
}
\value{
An object of class \code{cor_phylo}:
\item{\code{call}}{The matched call.}
\item{\code{corrs}}{The \code{p} x \code{p} matrix of correlation coefficients.}
\item{\code{d}}{Values of \code{d} from the OU process for each trait.}
\item{\code{B}}{A matrix of regression-coefficient estimates, SE, Z-scores, and P-values,
respectively. Rownames indicate which coefficient it refers to.}
\item{\code{B_cov}}{Covariance matrix for regression coefficients.}
\item{\code{logLik}}{The log likelihood for either the restricted likelihood
(\code{REML = TRUE}) or the overall likelihood (\code{REML = FALSE}).}
\item{\code{AIC}}{AIC for either the restricted likelihood (\code{REML = TRUE}) or the
overall likelihood (\code{REML = FALSE}).}
\item{\code{BIC}}{BIC for either the restricted likelihood (\code{REML = TRUE}) or the
overall likelihood (\code{REML = FALSE}).}
\item{\code{niter}}{Number of iterations the optimizer used.}
\item{\code{convcode}}{Conversion code for the optimizer.
This number is \code{0} on success and positive on failure if using
\code{\link[stats]{optim}}.
This number is positive on success and negative on failure if using nlopt
(see also
\url{https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values}).}
\item{\code{bootstrap}}{A list of bootstrap output, which is simply \code{list()} if
\code{boot = 0}. If \code{boot > 0}, then the list contains fields for
estimates of correlations (\code{corrs}), phylogenetic signals (\code{d}),
coefficients (\code{B0}), and coefficient covariances (\code{B_cov}).
It also contains the following information about the bootstrap replicates:
a vector of indices relating each set of information to the bootstrapped
estimates (\code{inds}),
convergence codes (\code{codes}), and
matrices of the bootstrapped parameters in the order they appear in the input
argument (\code{mats});
these three fields will be empty if \code{keep_boots == "none"}.
To view bootstrapped confidence intervals, use \code{\link{boot_ci}}.}

A list of confidence intervals for
estimates of correlations (\code{corrs}),
phylogenetic signals (\code{d}),
coefficient estimates (\code{B0}), and
coefficient covariances (\code{B_cov}).
}
\description{
This function calculates Pearson correlation coefficients for multiple continuous
traits that may have phylogenetic signal, allowing users to specify measurement
error as the standard error of trait values at the tips of the phylogenetic tree.
Phylogenetic signal for each trait is estimated from the data assuming that trait
evolution is given by a Ornstein-Uhlenbeck process.  Thus, the function allows the
estimation of phylogenetic signal in multiple traits while incorporating
correlations among traits. It is also possible to include independent variables
(covariates) for each trait to remove possible confounding effects.
\code{cor_phylo} returns the correlation matrix for trait values, estimates
of phylogenetic signal for each trait, and regression coefficients for
independent variables affecting each trait.
}
\details{
For the case of two variables, the function estimates parameters for the model of
the form, for example,

\deqn{X[1] =  B[1,0] + B[1,1] * u[1,1] + \epsilon[1]}
\deqn{X[2] =  B[2,0] + B[2,1] * u[2,1] + \epsilon[2]}
\deqn{\epsilon ~ Gaussian(0, V) }

where \eqn{B[1,0]}, \eqn{B[1,1]}, \eqn{B[2,0]}, and \eqn{B[2,1]} are regression
coefficients, and \eqn{V} is a variance-covariance matrix containing the correlation
coefficient r, parameters of the OU process \eqn{d1} and \eqn{d2}, and diagonal
matrices \eqn{M1} and \eqn{M2} of measurement standard errors for \eqn{X[1]} and
\eqn{X[2]}. The matrix \eqn{V} is \eqn{2n x 2n}, with \eqn{n x n} blocks given by

\deqn{V[1,1] = C[1,1](d1) + M1}
\deqn{V[1,2] = C[1,2](d1,d2)}
\deqn{V[2,1] = C[2,1](d1,d2)}
\deqn{V[2,2] = C[2,2](d2) + M2}

where \eqn{C[i,j](d1,d2)} are derived from \code{phy} under the assumption of joint
OU evolutionary processes for each trait (see Zheng et al. 2009). This formulation
extends in the obvious way to more than two traits.
}
\section{Methods (by generic)}{
\itemize{
\item \code{boot_ci}: returns bootstrapped confidence intervals from a \code{cor_phylo} object

\item \code{print}: prints \code{cor_phylo} objects
}}

\examples{

## Simple example using data without correlations or phylogenetic
## signal. This illustrates the structure of the input data.

phy <- ape::rcoal(10, tip.label = 1:10)
data_df <- data.frame(species = phy$tip.label,
                      par1 = rnorm(10),
                      par2 = rnorm(10),
                      cov2 = rnorm(10, mean = 10, sd = 4),
                      se1 = 0.2,
                      se2 = 0.4)
data_df$par2 <- data_df$par2 + 0.5 * data_df$cov2

cor_phylo(list(par1 ~ 1 | se1, par2 ~ cov2 | se2),
          species = species, phy = phy, data = data_df)


\dontrun{
    ## Simulation example for the correlation between two variables. The example
    ## compares the estimates of the correlation coefficients from cor_phylo when
    ## measurement error is incorporated into the analyses with three other cases:
    ## (i) when measurement error is excluded, (ii) when phylogenetic signal is
    ## ignored (assuming a "star" phylogeny), and (iii) neither measurement error
    ## nor phylogenetic signal are included.
    
    # In the simulations, variable 2 is associated with a single independent variable.
    
    library(ape)
    
    set.seed(1)
    # Set up parameter values for simulating data
    n <- 50
    phy <- rcoal(n, tip.label = 1:n)
    
    R <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
    d <- c(0.3, 0.95)
    B2 <- 1
    
    Se <- c(0.2, 1)
    M <- matrix(Se, nrow = n, ncol = 2, byrow = TRUE)
    
    # Set up needed matrices for the simulations
    p <- length(d)
    
    star <- stree(n)
    star$edge.length <- array(1, dim = c(n, 1))
    star$tip.label <- phy$tip.label
    
    Vphy <- vcv(phy)
    Vphy <- Vphy/max(Vphy)
    Vphy <- Vphy/exp(determinant(Vphy)$modulus[1]/n)
    
    tau <- matrix(1, nrow = n, ncol = 1) \%*\% diag(Vphy) - Vphy
    C <- matrix(0, nrow = p * n, ncol = p * n)
    for (i in 1:p) for (j in 1:p) {
        Cd <- (d[i]^tau * (d[j]^t(tau)) * (1 - (d[i] * d[j])^Vphy))/(1 - d[i] * d[j])
        C[(n * (i - 1) + 1):(i * n), (n * (j - 1) + 1):(j * n)] <- R[i, j] * Cd
    }
    MM <- matrix(M^2, ncol = 1)
    V <- C + diag(as.numeric(MM))
    
    # Perform a Cholesky decomposition of Vphy. This is used to generate phylogenetic
    # signal: a vector of independent normal random variables, when multiplied by the
    # transpose of the Cholesky deposition of Vphy will have covariance matrix
    # equal to Vphy.
    iD <- t(chol(V))
    
    # Create mostly empty data frame for input to cor_phylo
    data_df <- data.frame(species = phy$tip.label,
                          par1 = numeric(n),
                          par2 = numeric(n),
                          cov2 = numeric(n),
                          se1 = Se[1],
                          se2 = Se[2])
    
    # Perform Nrep simulations and collect the results
    Nrep <- 100
    cor.list <- matrix(0, nrow = Nrep, ncol = 1)
    cor.noM.list <- matrix(0, nrow = Nrep, ncol = 1)
    cor.noP.list <- matrix(0, nrow = Nrep, ncol = 1)
    cor.noMP.list <- matrix(0, nrow = Nrep, ncol = 1)
    d.list <- matrix(0, nrow = Nrep, ncol = 2)
    d.noM.list <- matrix(0, nrow = Nrep, ncol = 2)
    B.list <- matrix(0, nrow = Nrep, ncol = 3)
    B.noM.list <- matrix(0, nrow = Nrep, ncol = 3)
    B.noP.list <- matrix(0, nrow = Nrep, ncol = 3)
    
    set.seed(2)
    for (rep in 1:Nrep) {
        
        XX <- iD \%*\% rnorm(2 * n)
        
        data_df$cov2 <- rnorm(n, mean = 2, sd = 10)
        data_df$par1 <- XX[1:n]
        data_df$par2 <- XX[(n+1):(2*n)] + B2[1] * data_df$cov2 - B2[1] * 
                        mean(data_df$cov2)
        
        # Call cor_phylo with (i) phylogeny and measurement error,
        # (ii) just phylogeny,
        # and (iii) just measurement error
        z <- cor_phylo(list(par1 ~ 1 | se1, par2 ~ cov2 | se2),
                       phy = phy,
                       species = species, data = data_df)
        z.noM <- cor_phylo(list(par1 ~ 1, par2 ~ cov2),
                           phy = phy,
                           species = species, data = data_df)
        z.noP <- cor_phylo(list(par1 ~ 1 | se1, par2 ~ cov2 | se2),
                           phy = star,
                           species = species, data = data_df)
    
        cor.list[rep] <- z$corrs[1, 2]
        cor.noM.list[rep] <- z.noM$corrs[1, 2]
        cor.noP.list[rep] <- z.noP$corrs[1, 2]
        cor.noMP.list[rep] <- cor(cbind(
            lm(data_df$par1 ~ 1)$residuals,
            lm(data_df$par2 ~ data_df$cov2)$residuals))[1,2]
        
        d.list[rep, ] <- z$d
        d.noM.list[rep, ] <- z.noM$d
        
        B.list[rep, ] <- z$B[,1]
        B.noM.list[rep, ] <- z.noM$B[,1]
        B.noP.list[rep, ] <- z.noP$B[,1]
        
        show(c(rep, z$convcode, z$cor.matrix[1, 2], z$d))
    }
    
    correlation <- rbind(R[1, 2], mean(cor.list), mean(cor.noM.list),
                         mean(cor.noP.list), mean(cor.noMP.list))
    rownames(correlation) <- c("True", "With M and Phy", "Without M",
                               "Without Phy", "Without Phy or M")
    
    signal.d <- rbind(d, colMeans(d.list), colMeans(d.noM.list))
    rownames(signal.d) <- c("True", "With M and Phy", "Without M")
    
    est.B <- rbind(c(0, 0, B2), colMeans(B.list), 
                   colMeans(B.noM.list[-39,]),  # 39th rep didn't converge
                   colMeans(B.noP.list))
    rownames(est.B) <- c("True", "With M and Phy", "Without M", "Without Phy")
    colnames(est.B) <- rownames(z$B)
    
    # Example simulation output:

    correlation
    #                       [,1]
    # True             0.7000000
    # With M and Phy   0.6982181
    # Without M        0.2981836
    # Without Phy      0.3716215
    # Without Phy or M 0.3291473

    signal.d
    #                     [,1]      [,2]
    # True           0.3000000 0.9500000
    # With M and Phy 0.3061635 0.9418578
    # Without M      0.2405632 0.4013655

    est.B
    #                      par1_0    par2_0 par2_cov2
    # True            0.000000000 0.0000000 1.0000000
    # With M and Phy -0.008680443 0.1093704 0.9996207
    # Without M      -0.008561169 0.1146912 0.9982136
    # Without Phy     0.002933341 0.1096578 1.0028468
    
}


}
\references{
Zheng, L., A. R. Ives, T. Garland, B. R. Larget, Y. Yu, and K. F. Cao.
2009. New multivariate tests for phylogenetic signal and trait correlations
applied to ecophysiological phenotypes of nine \emph{Manglietia} species.
\emph{Functional Ecology} \bold{23}:1059--1069.
}
\author{
Anthony R. Ives, Lucas A. Nell
}
\keyword{regression}
